#/usr/bin/env python

""" TelepathyX Core that runs on the VM to orchestrate communication between XBee Proxy and
AutoTest driver """

from datetime import datetime
import logging
import os
import Queue
import select
import socket
import struct
import sys
import time

# custom modules
import tpx_utils as utils


class TPXCoreClient(object):
    """
    docstring here
    """

    def __init__(self, host, port, **kwargs):
        self.host = host
        self.port = port
        self.sock = None
        self.rlist = []
        self.wlist = []
        self.select_timeout = 10
        self.msg_queue = {}
        self.peername = None
        self.sockname = None

        # keyword argument options
        self.blocking = kwargs.pop("blocking", True)
        save_logs = kwargs.pop("save_logs", False)

        # configure logging settings
        logfile = "tpx_client_log.txt"
        utils.configure_logging(logfile, save_logs)
        logging.info("TelepathyX Client Started!")

        # init client socket
        self.init_client()

    def init_client(self):
        """ Initializes client """

        # create socket for client
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # reuse localhost loopback path
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        # connect to server socket
        try:
            logging.info("Attemtping to connect to '%s' on port %s", self.host, self.port)

            self.sock.connect((self.host, self.port))

            if self.blocking:
                self.sock.setblocking(1)
            else:
                self.sock.setblocking(0)

            # create queue for read and write
            self.msg_queue['read'] = Queue.Queue()
            self.msg_queue['write'] = Queue.Queue()

            self.rlist.append(self.sock)
            self.wlist.append(self.sock)

            self.sockname = self.sock.getsockname()

        except socket.error as msg:
            logging.critical("Connection failed. Error Code: %s - %s", msg[0], msg[1])
            logging.critical("Client shutdown! \n\n")
            sys.exit()

        else:
            logging.info("Connection to (%s, %s) successful on (%s, %s)", self.host, self.port,
                         self.sockname[0], self.sockname[1])

    def read_socket(self, bufsize=1024):
        """ blocking call of read socket """
        data = None
        try:

            assert self.blocking is True, "Socket is set as non-blocking"
            data = self.sock.recv(bufsize)

            if data:
                # A readable client socket must have data
                print "Received from '%s': %s" % (self.sock.getpeername(), data)
                self.msg_queue['read'].put(data)
            else:
                # empty result means closed connection
                print "NO DATA from %s" % (self.sock.getpeername()[1])
                print "Closing connection to", self.sock.getpeername(), "after reading no data"
                self.close_socket()

        except socket.error as msg:
            # No messages waiting so stop checking for writability
            logging.error("Read failed. Error Code: %s - %s", msg[0], msg[1])
            self.close_socket()

        return data

    def select_read_socket(self, bufsize=1024):
        """ Handles all client functions """

        assert self.blocking is False, "Socket is set as blocking"

        data = None
        readable, _, _ = select.select(self.rlist, self.wlist, self.rlist,
                                       self.select_timeout)

        if readable:
            self.read_socket(bufsize)
        else:
            print "Socket not readable"
            # print "Socket readable timeout after %s seconds!" %(self.select_timeout)

        return data

    def add_write_queue(self, msg):
        """" adds message to write queue """
        try:
            assert isinstance(msg, str), "MSG is not a str"
            self.msg_queue['write'].put(msg)
        except AssertionError:
            logging.error("Cannot add to MSG queue because argument is not type(str)")

    def write_socket(self):
        """ blocking call of write socket """

        assert self.blocking is True, "Socket is set as non-blocking"

        try:
            msg = self.msg_queue['write'].get_nowait()
            self.sock.send(msg)
            print 'Sent to %s - MSG: %s' % (self.sock.getpeername(), msg)

        except Queue.Empty:
            logging.debug("Called write_socket() on an empty queue")

        except socket.error as msg:
            # No messages waiting so stop checking for writability
            logging.error("Send failed. Error Code: %s - %s", msg[0], msg[1])
            self.close_socket()

    def select_write_socket(self):
        """ handle all writable sockets """

        assert self.blocking is False, "Socket is set as blocking"

        _, writable, _ = select.select(self.rlist, self.wlist, self.rlist,
                                       self.select_timeout)
        if writable:
            self.write_socket()

        else:
            print "Socket not writable"

    def close_socket(self):
        """ politely closes client socket on exception """

        try:
            logging.warning("Closing connection from (%s, %s) on socket (%s, %s)", self.host,
                            self.port, self.sockname[0], self.sockname[1])
            # self.sock.shutdown(1)
            self.sock.close()

        except socket.error:
            logging.warning("Could not cleanly close socket\n\n")
            print "Could not cleanly close socket\n\n"
            sys.exit()

        else:
            logging.info("\nSocket closed cleanly\n\n")
            print "\nSocket closed cleanly\n\n"
            sys.exit()

    def unpack_data(self, data):
        """ unpacks and returns data and xbee address"""
        # pylint: disable=no-self-use
        # data is packed in big-endian unsigned long long format
        xbee_addr = struct.unpack(">Q", data[:8])
        payload = data[8:]
        return payload, xbee_addr

    def select_socket(self):
        """ returns [readable], [writable], [exceptional] sockets """
        print "waiting"
        readable, writable, _ = select.select(self.rlist, self.wlist, self.rlist,
                                              self.select_timeout)

        print "Socket available"

        if readable:
            self.read_socket()
        else:
            print "Socket not readable"

        dtime = datetime.now().strftime("%I:%M:%S.%f")
        self.add_write_queue(dtime)
        self.write_socket()


def main():
    """ main function """
    # pylint: disable = unused-variable
    # xbee base station
    # telepathyx-connectport01

    # Xbee base station
    # host = '10.33.233.65'
    # port = 5005

    # localhost
    host = 'localhost'
    eth_port = 5005
    mgn_port = 5006
    debug_port = 5007
    save_logs = False

    eth_client = TPXCoreClient(host, eth_port, save_logs=save_logs)
    mgn_client = TPXCoreClient(host, mgn_port, save_logs=save_logs)
    debug_client = TPXCoreClient(host, debug_port, save_logs=save_logs)

    try:
        while True:

            dtime = datetime.now().strftime("%I:%M:%S.%f")
            debug_msg = "FROM DEBUG: %s" % (dtime)
            mgn_msg = "FROM MGN: %s" % (dtime)

            # eth_client.write_socket(dtime)
            debug_client.add_write_queue(debug_msg)
            mgn_client.add_write_queue(mgn_msg)

            debug_client.write_socket()
            mgn_client.write_socket()
            time.sleep(1)

            eth_client.read_socket()
            mgn_client.read_socket()
            debug_client.read_socket()

    except KeyboardInterrupt:
        # print '\n\n Keyboard Interrupt'
        # logging.info("KeyboardInterrupt")
        eth_client.close_socket()
        mgn_client.close_socket()
        debug_client.close_socket()


if __name__ == "__main__":
    main()
